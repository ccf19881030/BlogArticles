## [GB2312、GBK与UTF-8的区别](https://blog.csdn.net/ZYY88886666/article/details/75285780)
首先，我们要明白，GB2312、GBK和UTF-8都是一种字符编码，除此之外，还有好多字符编码。只是对于我们中国人的网站来说，用这三种编码 比较多。简单的说一下，为什么要用编码，在计算机内，储存文本信息用ASC II码，每一个字符对应着唯一的ASCII码。最初计算机是由美国发明的，他们也用的是键盘和上面的字母，所以他们的字符ASCII好解决。但是我们中国 的就不同了，每个汉字要对应唯一的ASCII码。这样，就出来了国家制定的字符编码标准：GB2312、GBK等。其他国家，其他语言也有他们对应的编码 标准。 GB 就是国标的意思，GB2312和GBK主要用于汉字的编码，而UTF-8是全世界通用的。意思就是说，如果你的网页主要面对使用汉语的中国人的话，使用 GB2312和GBK非常好，文字储存体积要小，有一些优点。如果你的网页要面向世界的话，你再用GB2312和GBK作为网页编码的话，有些电脑上的浏 览器没有这种编码，你的网页汉字内容就会变成无法识别的乱码。 它们通常用在网页的meta标签内，例如：，表示这个页面使用的是GB2312编码。这个信息是给浏览器看的，浏览器会优先考虑使用从网页头部提取出来的编码信息对网页进行解码。当然， 我们也可以强制浏览器使用某种编码解释网页，这样我们就看到了传说中的乱码。

GBK、GB2312等与UTF8之间都必须通过Unicode编码才能相互转换：
GBK、GB2312－－Unicode－－UTF8
UTF8－－Unicode－－GBK、GB2312
对于一个网站、论坛来说，如果英文字符较多，则建议使用UTF－8节省空间。不过现在很多论坛的插件一般只支持GBK。
如果是中文的网站 推荐GB2312 GBK有时还是有点问题 为了避免所有乱码问题，应该采用UTF-8，将来要支持国际化也非常方便 UTF-8可以看作是大字符集，它包含了大部分文字的编码。

使用UTF-8的一个好处是其他地区的用户（如香港台湾）无需安装简体中文支持就能正常观看你的文字*而不会出现乱码。*
gb2312是简体中文的码
gbk支持简体中文及繁体中文
big5支持繁体中文
utf-8支持几乎所有字符
中国大陆最常用的就是GBK18030编码，除此之外还有GBK，GB2312，这几个编码的关系是这样的。 最早制定的汉字编码是GB2312，包括6763个汉字和682个其它符号 95年重新修订了编码，命名GBK1.0，共收录了21886个符号。 之后又推出了GBK18030编码，共收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字，现在WINDOWS平台必需要支持GBK18030编码。

GB2312编码大约包含6000多汉字（不包括特殊字符）,编码范围为第一位b0-f7,第二位编码范围为a1-fe(第一位为cf时,第二位为a1-d3),计算一下汉字个数为6762个汉字。当然还有其他的字符。包括控制键和其他字符大约7573个字符编码 gbk编码是对G B2312编码的扩充，容纳的汉字更多，但仅仅是扩充，没有质的变化。保留了所有G B2312编码,在此基础上进行编码范围的扩充.容纳(包含特殊字符)共22014个字符编码. gb18030编码是在gbk编码基础上的扩充，因为汉字更多，仅仅使用两位编码已经不能 容纳要求的汉字，所以采用了2\4位混和的办法，可以支持更多的汉字编码。并且保留了原有的gbk 2字节编码兼容G B2312和gbk编码的文件。大概容纳55657个编码(包含特殊字符) unicode编码(也就是UTF编码)：俗称万国码，致力于使用统一的编码准则表达各国的文字。 为表达更多的文字，utf-8采用2/3混编的方式。目前容纳的汉字范围小于gbk编码。并且以 3字节的方式处理中文，带来了兼容性的问题，原有的gbk,G B2312,gb18030编码文件都不能正常的处理,还有很长的路要走。

## [boost 实现 GB2312 到 UTF-8 的相互转换](https://blog.csdn.net/fm_vae/article/details/48677953)
头文件   `#include  <boost/locale.hpp>`
实现函数：
```cpp
std::string CodeConvert( const char* in_buf,const char* from_charset,const char* to_charset)
{
    std::string ret(in_buf);
    if ( strcmp(from_charset, "gb2312") == 0 && strcmp(to_charset, "utf-8") == 0 )
        ret = boost::locale::conv::to_utf<char>(in_buf, std::string("gb2312"));
    else if ( strcmp(from_charset, "utf-8") == 0 && strcmp(to_charset, "gb2312") == 0 )
        ret = boost::locale::conv::from_utf(in_buf, std::string("gb2312"));
    return ret;
}
```

